package com.nuix.evmanager.data;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringJoiner;
import java.util.function.Consumer;

import org.apache.log4j.Logger;
import org.joda.time.DateTime;

/***
 * Encapsulates information about the SQL address book database.
 * @author Jason Wells
 *
 */
public class SQLUserRecordStore implements UserRecordStore {
	private static Logger logger = Logger.getLogger(SQLUserRecordStore.class);
	private static boolean useFullTextFiltering = false;
	public static void setUseFullTextFiltering(boolean value){ useFullTextFiltering = value; }
	public static boolean getUseFullTextFiltering(){ return useFullTextFiltering; }
	
	private Map<String,Object> databaseConnectionSettings = new HashMap<String,Object>();
	
	/***
	 * Creates a new instance with the given database connection settings.
	 * @param databaseConnectionSettings A Map of settings used to connect to the backing database.
	 */
	public SQLUserRecordStore(Map<String,Object> databaseConnectionSettings){
		this.databaseConnectionSettings = databaseConnectionSettings;
	}
	
	/***
	 * Returns the Map of database settings associated to this instance.
	 * @return
	 */
	public Map<String,Object> getDatabaseConnectionSettings(){
		return this.databaseConnectionSettings;
	}
	
	private String cachedConnectionString = null;
	/***
	 * Builds a connection string based on the settings of this instance.
	 * @return A connection string suitable for usage by {@link java.sql.DriverManager#getConnection(String)}
	 */
	public String getConnectionString(){
		if(cachedConnectionString == null){
			cachedConnectionString = "jdbc:jtds:sqlserver://";
			
			// Server
			if(databaseConnectionSettings.containsKey("server") && databaseConnectionSettings.get("server") != null){
				cachedConnectionString += databaseConnectionSettings.get("server");
			} else {
				cachedConnectionString += "localhost";
			}
			
			//Port
			if(databaseConnectionSettings.containsKey("port") && databaseConnectionSettings.get("port") != null){
				cachedConnectionString += ":"+databaseConnectionSettings.get("port");
			}
			
			//Database
			if(databaseConnectionSettings.containsKey("database") && databaseConnectionSettings.get("database") != null){
				cachedConnectionString += "/"+databaseConnectionSettings.get("database");
			}
			
			// Instance Name
			if(databaseConnectionSettings.containsKey("instance") && databaseConnectionSettings.get("instance") != null){
				cachedConnectionString += ";instance="+databaseConnectionSettings.get("instance");
			}
	
			// Domain Name
			if(databaseConnectionSettings.containsKey("domain") && databaseConnectionSettings.get("domain") != null){
				cachedConnectionString += ";domain="+databaseConnectionSettings.get("domain");
			}
			
			//User and password
			if(databaseConnectionSettings.containsKey("user") && databaseConnectionSettings.get("user") != null){
				cachedConnectionString += ";user="+databaseConnectionSettings.get("user");
			}
			if(databaseConnectionSettings.containsKey("password") && databaseConnectionSettings.get("password") != null){
				cachedConnectionString += ";password="+databaseConnectionSettings.get("password");
			}
			
			//Prevents an issue while retrieving some text fields from DB
			cachedConnectionString += ";useLOBs=false;zeroDateTimeBehavior=convertToNull";
		}
		
		return cachedConnectionString;
	}
	
	/***
	 * Creates a database connection using the connection string generated by a call
	 * to {@link #getConnectionString()}.
	 * @return A Connection to the database
	 * @throws SQLException Thrown if there is an error connecting to the database
	 */
	public Connection createConnection() throws SQLException{
		return DriverManager.getConnection(getConnectionString());
	}
	
	/***
	 * Attempts to connect to the address book database using the settings of this instance and perform a simple SQL query:
	 * "SELECT COUNT(1) AS Result FROM UserRecord" to make sure that both the connection can be made and that the user record
	 * table can be queried.
	 * @return True if a connection can be made and the UserRecord table can be queried, false otherwise
	 */
	public boolean canConnect(){
		logger.info("Testing database connection...");
		try {
			String testQuery = "SELECT COUNT(1) AS Result FROM UserRecord";
			logger.info("Running test query: "+testQuery);
			Integer result = (Integer)runQuery(testQuery, (List<Object>)null).get(0).get("Result");
			
			if(result == null) {
				logger.info("Returned result was null, considering this failure to connect");
			} else if (result < 1) {
				logger.info("Returned result ("+result+") is less than 1, considering this failure to connect");
			} else {
				return true;
			}
		} catch (Exception e) {
			logger.error("Error while attempting test connection to user record database",e);
			e.printStackTrace();
		}
		return false;
	}
	
	/***
	 * Convenience method for running a query against the database.  Returns all results,
	 * so for queries which may retrieve a large set of results, you may want to instead
	 * consider using {@link #runQuery(String, List, Consumer)}.
	 * @param sql The SQL query to run
	 * @param data A list of data to be bound to the statement, can be null
	 * @return A list of Maps, each Map represents a record in the database
	 * @throws Exception
	 */
	public List<LinkedHashMap<String,Object>> runQuery(String sql, List<Object> data) throws Exception{
		List<LinkedHashMap<String,Object>> result = new ArrayList<LinkedHashMap<String,Object>>();
		try(Connection conn = createConnection()){
			PreparedStatement ps = conn.prepareStatement(sql);
			bindData(ps,data);
			ResultSet resultSet = ps.executeQuery();
			ResultSetMetaData md = resultSet.getMetaData();
			int columnCount = md.getColumnCount();
			while(resultSet.next()){
				LinkedHashMap<String,Object> record = new LinkedHashMap<String,Object>();
				for (int c = 1; c <= columnCount; c++) {
					record.put(md.getColumnName(c),resultSet.getObject(c));
					
				}
				result.add(record);
			}
		}
		return result;
	}
	
	/***
	 * Convenience method for running a query against the database.  Returns all results,
	 * so for queries which may retrieve a large set of results, you may want to instead
	 * consider using {@link #runQuery(String, List, Consumer)}.
	 * @param sql The SQL query to run
	 * @param data A var args list of data to be bound to the statement, can be null
	 * @return A list of Maps, each Map represents a record in the database
	 * @throws Exception
	 */
	public List<LinkedHashMap<String,Object>> runQuery(String sql, Object... data) throws Exception{
		return runQuery(sql,Arrays.asList(data));
	}
	
	/***
	 * Convenience method for running a query against the database.  Passes each record to provided
	 * Consumer as it is read from the database.  Can be a better alternative to {@link #runQuery(String, List)} and
	 * {@link #runQuery(String, Object...)} when the result set may be large as it does not materialize the entire
	 * result set in memory before returning.
	 * @param sql The SQL query to run
	 * @param data A list of data to be bound to the statement, can be null
	 * @param callback An instance of Consumer which will be passed each record as it is read from the database
	 * @throws Exception
	 */
	public void runQuery(String sql, List<Object> data, Consumer<LinkedHashMap<String,Object>> callback) throws Exception{
		try(Connection conn = createConnection()){
			PreparedStatement ps = conn.prepareStatement(sql);
			bindData(ps,data);
			ResultSet resultSet = ps.executeQuery();
			ResultSetMetaData md = resultSet.getMetaData();
			int columnCount = md.getColumnCount();
			LinkedHashMap<String,Object> record = new LinkedHashMap<String,Object>();
			while(resultSet.next()){
				record.clear();
				for (int c = 1; c <= columnCount; c++) {
					record.put(md.getColumnName(c),resultSet.getObject(c));
					
				}
				callback.accept(record);
			}
		}
	}
	
	/***
	 * Convenience method for running a SQL update statement (something which returns no data).
	 * @param sql The SQL query to run
	 * @param data A list of data to be bound to the statement, can be null
	 * @throws SQLException
	 */
	public void runUpdate(String sql, List<Object> data) throws SQLException{
		try(Connection conn = createConnection()){
			PreparedStatement ps = conn.prepareStatement(sql);
			bindData(ps,data);
			ps.executeUpdate();
		}
	}
	
	/***
	 * Convenience method for running a SQL update statement (something which returns no data).
	 * @param sql The SQL query to run
	 * @param data A var args list of data to be bound to the statement, can be null
	 * @throws SQLException
	 */
	public void runUpdate(String sql, Object... data) throws SQLException{
		runUpdate(sql,Arrays.asList(data));
	}
	
	/***
	 * Binds data to a PreparedStatement in the order provided.  Uses
	 * <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setObject-int-java.lang.Object-java.sql.SQLType-">java.sql.PreparedStatment.setObject</a>
	 * to bind data, which determine an appropriate SQL data type for each object.
	 * @param ps
	 * @param data
	 * @throws SQLException
	 */
	public void bindData(PreparedStatement ps, List<Object> data) throws SQLException{
		if(data != null){
			for (int i = 0; i < data.size(); i++) {
				Object value = data.get(i);
				if(value instanceof DateTime){
					java.sql.Timestamp date = new java.sql.Timestamp(((DateTime)value).getMillis());
					ps.setTimestamp(i+1,date);
				} else {
					ps.setObject(i+1,value);	
				}
			}
		}
	}

	/***
	 * Gets a user record result based on the provided user record criteria.
	 * @param criteria The criteria used to obtain a user record reuslt set
	 * @return The resulting user record result object
	 */
	public SQLUserRecordResult findRecords(UserRecordCriteria criteria) {
		Map<String,String> criteriaMap = criteria.toMap();
		if(criteriaMap.size() > 0){
			List<String> queryCriteria = new ArrayList<String>();
			List<Object> queryData = new ArrayList<Object>();
			if(useFullTextFiltering){
				for(Map.Entry<String, String> entry : criteriaMap.entrySet()){
					for(String term : entry.getValue().split("[^a-zA-Z0-9]+")){
						String c = "CONTAINS("+entry.getKey()+",?)";
						queryCriteria.add(c);
						queryData.add("\"*"+term+"*\"");
					}
				}
			} else {
				for(Map.Entry<String, String> entry : criteriaMap.entrySet()){
					for(String term : entry.getValue().split("[^a-zA-Z0-9]+")){
						queryCriteria.add(entry.getKey()+" LIKE ?");
						queryData.add("%"+term+"%");
					}
				}	
			}
			String whereClause = "WHERE "+String.join(" AND ",queryCriteria);
			System.out.println("DEBUG: User Record Where Clause: "+whereClause);
			return new SQLUserRecordResult(this,whereClause,queryData);
		} else {
			return new SQLUserRecordResult(this,"",new ArrayList<Object>());
		}
	}

	/***
	 * Obtains a distinct list of location values from the database UserRecord.Location
	 * @return A distinct list of user location values in the database
	 */
	public List<String> getAllLocations() throws Exception {
		Set<String> locations = new HashSet<String>();
		runQuery("SELECT DISTINCT(Location) FROM UserRecord", null, new Consumer<LinkedHashMap<String,Object>>(){
			@Override
			public void accept(LinkedHashMap<String, Object> record) {
				locations.add((String) record.get("Location"));
			}
		});
		return new ArrayList<String>(locations);
	}

	/***
	 * Gets a list of distinct title values from the database UserRecord.Title
	 * @return A list of distinct user titles in the database
	 */
	public List<String> getAllTitles() throws Exception {
		Set<String> titles = new HashSet<String>();
		runQuery("SELECT DISTINCT(Title) FROM UserRecord", null, new Consumer<LinkedHashMap<String,Object>>(){
			@Override
			public void accept(LinkedHashMap<String, Object> record) {
				titles.add((String) record.get("Title"));
			}
		});
		return new ArrayList<String>(titles);
	}


	/***
	 * Gets a list of distinct department values from the database UserRecord.Department
	 * @return A list of distinct user depart values in the database
	 */
	public List<String> getAllDepartments() throws Exception {
		Set<String> departments = new HashSet<String>();
		runQuery("SELECT DISTINCT(Department) FROM UserRecord", null, new Consumer<LinkedHashMap<String,Object>>(){
			@Override
			public void accept(LinkedHashMap<String, Object> record) {
				departments.add((String) record.get("Department"));
			}
		});
		return new ArrayList<String>(departments);
	}

	/***
	 * Processes an address change order by making changes defined by that change order to the database.
	 * @param changeOrder The change order object from which defined changes will be made.
	 */
	@Override
	public void processAddressChangeOrder(AddressChangeOrder changeOrder) throws Exception {
		logger.info("Processing user change order: "+changeOrder.getLogSummary());
		
		List<Object> bindData = new ArrayList<Object>();
		SQLUserRecord associatedUserRecord = changeOrder.getAssociatedUserRecord();
		
		String insertSql = "INSERT INTO UserAddress (UserRecordID,RecordCreated,Address) VALUES (?,?,?)";
		for(UserAddress newAddress : changeOrder.getNewAddresses()){
			bindData.clear();
			bindData.add(associatedUserRecord.getDatabaseID());
			bindData.add(new DateTime());
			bindData.add(newAddress.getAddress());
			runUpdate(insertSql, bindData);
		}
		
		String updateSql = "UPDATE UserAddress SET Address = ?, RecordLastModified = ? WHERE ID = ?";
		for(UserAddress updatedAddress : changeOrder.getUpdatedAddresses()){
			bindData.clear();
			bindData.add(updatedAddress.getAddress());
			bindData.add(new DateTime());
			bindData.add(updatedAddress.getDatabaseID());
			runUpdate(updateSql, bindData);
		}
		
		String deleteSql = "DELETE FROM UserAddress WHERE ID = ?";
		for(UserAddress deletedAddress : changeOrder.getDeletedAddresses()){
			bindData.clear();
			bindData.add(deletedAddress.getDatabaseID());
			runUpdate(deleteSql, bindData);
		}
	}

	/***
	 * Records an ingestion event.
	 * @param custodian The user record to associate the even to
	 * @param caseName The name of the case
	 * @param caseLocation The location of the case
	 * @param dataName The name to associate
	 * @throws Exception Most likely thrown if are exceptions thrown while interacting with the database
	 */
	public void recordCustodianIngestionEvent(SQLUserRecord custodian, String caseName, String caseLocation, String dataName) throws Exception{
		// TODO: Implement more advanced history entries
		//String insertSql = "INSERT INTO IngestionHistory (UserRecordID,DateIngested,CaseName,CaseLocation,DataName) VALUES (?,?,?,?,?)";
		
		String insertSql = "INSERT INTO IngestionHistory (UserRecordID,DateIngested,CaseName,CaseLocation) VALUES (?,?,?,?)";
		
		DateTime dateIngested = new DateTime();
		List<Object> bindData = new ArrayList<Object>();
		bindData.add(custodian.databaseID);
		bindData.add(dateIngested);
		bindData.add(caseName);
		bindData.add(caseLocation);

		// TODO: Implement more advanced history entries
		//bindData.add(dataName);
		
		StringJoiner logInfo = new StringJoiner("\n");
		logInfo.add("Recording ingestion history entry:");
		logInfo.add("UserRecordID: "+custodian.databaseID);
		logInfo.add("DateIngested: "+dateIngested);
		logInfo.add("CaseName: "+caseName);
		logInfo.add("CaseLocation: "+caseLocation);
		//logInfo.add("DataName: "+dataName);
		logger.info(logInfo.toString());
		
		try {
			runUpdate(insertSql, bindData);
		} catch (Exception e) {
			logger.error("Error while saving ingestion history event to address bookd database",e);
			throw e;
		}
	}
	
	/***
	 * Tests whether a user record with the given employeed ID exists in the address book database
	 * @param employeeId The employee ID to look for
	 * @return True if the given employee ID is able to be located in the address book database
	 * @throws Exception Most likely thrown if the database connectivity throws an exception
	 */
	public boolean employeedIdExists(String employeeId) throws Exception{
		List<Object> bindData = new ArrayList<Object>();
		bindData.add(employeeId.trim());
		List<LinkedHashMap<String,Object>> records = runQuery("SELECT COUNT(1) AS Count FROM UserRecord WHERE EmployeeID = ?", bindData);
		int count = (Integer)records.get(0).get("Count");
		return count > 0;
	}
	
	/***
	 * Adds a user record to the database if it does not already exist.  User existence should be pre-qualified by a call to {@link #employeedIdExists(String)}.
	 * @param record The user record to add
	 * @return True if the record was successfully added to the database
	 * @throws Exception If the EmployeeID of the provided user record is empty or only whitespace, if the given employeed ID exists in the database or there is database connectivity issues.
	 */
	public boolean addUserRecord(UserRecord record) throws Exception{
		if(record.getEmployeeID().trim().isEmpty()){
			throw new Exception("EmployeedID maybe not be a blank value");
		}
		
		if(employeedIdExists(record.getEmployeeID().trim())){
			throw new Exception("EmployeeID "+record.getEmployeeID().trim()+" already exists in the database");
		}
		
		boolean success = true;
		
		String insertUserBaseData = "INSERT INTO UserRecord (EmployeeID,Name,Title,Department,Location,RecordCreated,RecordLastModified) VALUES (?,?,?,?,?,?,?)";
		String insertAddressSql = "INSERT INTO UserAddress (Address,UserRecordID) VALUES (?,?)";
		String insertPhoneNumberSql = "INSERT INTO UserPhoneNumber (PhoneNumber,UserRecordID) VALUES (?,?)";
		String insertSidSql = "INSERT INTO UserSID (SID,UserRecordID) VALUES (?,?)";
		
		List<Object> data = new ArrayList<Object>();
		
		Connection conn = null;
		try{
			conn = createConnection();
			conn.setAutoCommit(false);
			
			// Insert user's base data
			long userId = -1;
			
			{
				DateTime timeStamp = DateTime.now();
				PreparedStatement ps = conn.prepareStatement(insertUserBaseData, new String[]{"ID"});
				data.clear();
				data.add(record.getEmployeeID());
				data.add(record.getName());
				data.add(record.getTitle());
				data.add(record.getDepartment());
				data.add(record.getLocation());
				data.add(timeStamp);
				data.add(timeStamp);
				bindData(ps,data);
				ps.executeUpdate();
				
				// now get the ID:
				ResultSet rs = ps.getGeneratedKeys();
				if (rs.next()) {
					userId = rs.getLong(1);
				} else {
					throw new Exception("Unable to located ID for base UserRecord entry.");
				}
			}
			
			// Insert email addresses
			for(UserAddress address : record.getAddresses()){
				PreparedStatement ps = conn.prepareStatement(insertAddressSql);
				data.clear();
				data.add(address.getAddress());
				data.add(userId);
				bindData(ps,data);
				ps.executeUpdate();
			}
			
			// Insert phone numbers
			for(String phoneNumber : record.getPhoneNumbers()){
				PreparedStatement ps = conn.prepareStatement(insertPhoneNumberSql);
				data.clear();
				data.add(phoneNumber);
				data.add(userId);
				bindData(ps,data);
				ps.executeUpdate();
			}
			
			// Insert SIDs
			for(String sid : record.getSIDs()){
				PreparedStatement ps = conn.prepareStatement(insertSidSql);
				data.clear();
				data.add(sid);
				data.add(userId);
				bindData(ps,data);
				ps.executeUpdate();
			}
			
			conn.commit();
		} catch (Exception exc){
			success = false;
			if(conn != null){
				conn.rollback();
			}
			conn.rollback();
			logger.error("Error while inserting new user",exc);
			throw exc;
		} finally {
			if(conn != null){
				conn.close();
			}
		}
		
		return success;
	}
}
