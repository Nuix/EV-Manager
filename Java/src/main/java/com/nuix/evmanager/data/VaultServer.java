package com.nuix.evmanager.data;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

/***
 * Encapsulates connectivity to the EV backend SQL server.
 * @author Jason Wells
 *
 */
public class VaultServer {
	private static Logger logger = Logger.getLogger(VaultServer.class);
	
	private String cachedConnectionString = null;
	private String displayName;
	private Map<String,Object> databaseConnectionSettings;
	
	public VaultServer(String displayName, Map<String,Object> databaseConnectionSettings){
		this.displayName = displayName;
		this.databaseConnectionSettings = databaseConnectionSettings;
		buildConnectionString(databaseConnectionSettings);
	}
	
	/***
	 * Builds a connection string from the associated settings.
	 * @param databaseConnectionSettings A connection string suitable for {@link java.sql.DriverManager#getConnection(String)}.
	 */
	private void buildConnectionString(Map<String,Object> databaseConnectionSettings){
		cachedConnectionString = "jdbc:jtds:sqlserver://";
		
		// Server
		if(databaseConnectionSettings.containsKey("server") && databaseConnectionSettings.get("server") != null){
			cachedConnectionString += databaseConnectionSettings.get("server");
		} else {
			cachedConnectionString += "localhost";
		}
		
		//Port
		if(databaseConnectionSettings.containsKey("port") && databaseConnectionSettings.get("port") != null){
			cachedConnectionString += ":"+databaseConnectionSettings.get("port");
		}
		
		//Database
		if(databaseConnectionSettings.containsKey("database") && databaseConnectionSettings.get("database") != null){
			cachedConnectionString += "/"+databaseConnectionSettings.get("database");
		}
		
		// Instance Name
		if(databaseConnectionSettings.containsKey("instance") && databaseConnectionSettings.get("instance") != null){
			cachedConnectionString += ";instance="+databaseConnectionSettings.get("instance");
		}

		// Domain Name
		if(databaseConnectionSettings.containsKey("domain") && databaseConnectionSettings.get("domain") != null){
			cachedConnectionString += ";domain="+databaseConnectionSettings.get("domain");
		}
		
		//User and password
		if(databaseConnectionSettings.containsKey("user") && databaseConnectionSettings.get("user") != null){
			cachedConnectionString += ";user="+databaseConnectionSettings.get("user");
		}
		if(databaseConnectionSettings.containsKey("password") && databaseConnectionSettings.get("password") != null){
			cachedConnectionString += ";password="+databaseConnectionSettings.get("password");
		}
		
		//Prevents an issue while retrieving some text fields from DB
		cachedConnectionString += ";useLOBs=false;zeroDateTimeBehavior=convertToNull";
	}
	
	/***
	 * Creates a database connection using the connection string generated by a call
	 * to {@link #getConnectionString()}.
	 * @return A Connection to the database
	 * @throws SQLException Thrown if there is an error connecting to the database
	 */
	private Connection createConnection() throws SQLException{
		return DriverManager.getConnection(cachedConnectionString);
	}
	
	/***
	 * Convenience method for running a query against the database.  Returns all results,
	 * so for queries which may retrieve a large set of results, you may want to instead
	 * consider using {@link #runQuery(String, List, Consumer)}.
	 * @param sql The SQL query to run
	 * @param data A list of data to be bound to the statement, can be null
	 * @return A list of Maps, each Map represents a record in the database
	 * @throws Exception
	 */
	public List<LinkedHashMap<String,Object>> runQuery(String sql, List<Object> data) throws Exception{
		List<LinkedHashMap<String,Object>> result = new ArrayList<LinkedHashMap<String,Object>>();
		try(Connection conn = createConnection()){
			PreparedStatement ps = conn.prepareStatement(sql);
			bindData(ps,data);
			ResultSet resultSet = ps.executeQuery();
			ResultSetMetaData md = resultSet.getMetaData();
			int columnCount = md.getColumnCount();
			while(resultSet.next()){
				LinkedHashMap<String,Object> record = new LinkedHashMap<String,Object>();
				for (int c = 1; c <= columnCount; c++) {
					//System.out.println("Col: "+c);
					//System.out.println("Type: "+md.getColumnTypeName(c));
					record.put(md.getColumnName(c),resultSet.getObject(c));
					
				}
				result.add(record);
			}
		}
		return result;
	}
	
	/***
	 * Convenience method for running a query against the database.  Passes each record to provided
	 * Consumer as it is read from the database.  Can be a better alternative to {@link #runQuery(String, List)} and
	 * {@link #runQuery(String, Object...)} when the result set may be large as it does not materialize the entire
	 * result set in memory before returning.
	 * @param sql The SQL query to run
	 * @param data A list of data to be bound to the statement, can be null
	 * @param callback An instance of Consumer which will be passed each record as it is read from the database
	 * @throws Exception
	 */
	public void runQuery(String sql, List<Object> data, Consumer<LinkedHashMap<String,Object>> callback) throws Exception{
		try(Connection conn = createConnection()){
			PreparedStatement ps = conn.prepareStatement(sql);
			bindData(ps,data);
			ResultSet resultSet = ps.executeQuery();
			ResultSetMetaData md = resultSet.getMetaData();
			int columnCount = md.getColumnCount();
			LinkedHashMap<String,Object> record = new LinkedHashMap<String,Object>();
			while(resultSet.next()){
				record.clear();
				for (int c = 1; c <= columnCount; c++) {
					record.put(md.getColumnName(c),resultSet.getObject(c));
					
				}
				callback.accept(record);
			}
		}
	}
	
	/***
	 * Binds data to a PreparedStatement in the order provided.  Uses
	 * <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setObject-int-java.lang.Object-java.sql.SQLType-">java.sql.PreparedStatment.setObject</a>
	 * to bind data, which determine an appropriate SQL data type for each object.
	 * @param ps
	 * @param data
	 * @throws SQLException
	 */
	private void bindData(PreparedStatement ps, List<Object> data) throws SQLException{
		if(data != null){
			for (int i = 0; i < data.size(); i++) {
				Object value = data.get(i);
				ps.setObject(i+1,value);	
			}
		}
	}
	
	private List<VaultStore> evStores = null;
	/***
	 * Gets a list of vault stores from the database.  If the values have not been obtained and cached, they are fetched from the EV backend SQL server.  If they
	 * have already been obtained and cached, the existing store list is returned.
	 * @return List of vault stores
	 * @throws Exception Most likely thrown if there is an error communicating with SQL.
	 */
	public List<VaultStore> getStores() throws Exception{
		if(evStores == null){
			logger.info("Stores not yet cached, fetching...");
			evStores = new ArrayList<VaultStore>();
			try {
				String query = "SELECT\n"+
						"Store.VaultStoreName,\n"+
						"Store.VaultStoreDescription,\n"+
						"Store.VaultStoreEntryId,\n"+
						"Store.VaultStoreIdentity,\n"+
						"Computer.ComputerNameAlternate AS EVAPIServer\n"+
						"FROM VaultStoreEntry AS Store\n"+
						"INNER JOIN StorageServiceEntry AS StorageService ON Store.StorageServiceEntryId = StorageService.ServiceEntryId\n"+
						"INNER JOIN ComputerEntry AS Computer ON StorageService.ComputerEntryId = Computer.ComputerEntryId\n"+
						"ORDER BY Store.VaultStoreName ASC";
						
				runQuery(query, null, new Consumer<LinkedHashMap<String,Object>>(){
					@Override
					public void accept(LinkedHashMap<String, Object> data) {
						VaultStore store = VaultStore.createEVStore(
								VaultServer.this,
								(String)data.get("VaultStoreName"),
								(String)data.get("VaultStoreDescription"),
								(String)data.get("VaultStoreEntryId"),
								(Integer)data.get("VaultStoreIdentity"),
								(String)data.get("EVAPIServer")
							);
						evStores.add(store);
					}
				});
			} catch (Exception e) {
				logger.error("Error while retrieving server store listing",e);
				e.printStackTrace();
			}
		}
		return evStores;
	}
	
	/***
	 * Gets vault archive result for the given store and archive criteria.
	 * @param store The vault store
	 * @param criteria The archive criteria
	 * @return Vault archive result
	 * @throws Exception Most likely if there is SQL communication issues.
	 */
	public VaultArchiveResult getArchives(VaultStore store, VaultArchiveCriteria criteria) throws Exception{
		logger.info("Server "+getDisplayName()+" fetching archives for store ["+store.getName()+", "+store.getStoreEntryID()+"]");
		if (criteria != null){
			logger.info("Archive Name Criteria: "+criteria.getArchiveNameCriteria());
		}
		List<Object> bindData = new ArrayList<Object>();
		bindData.add(store.getStoreEntryID());
		String whereClause = "WHERE VaultStoreEntryId = ?";
		if(criteria != null){
			String nameCriteria = criteria.getArchiveNameCriteria();
			if(nameCriteria != null && nameCriteria.trim().length() > 0){
				whereClause += " AND ArchiveName LIKE ?";
				bindData.add("%"+nameCriteria+"%");
			}
		}
		return new VaultArchiveResult(this,store,whereClause,bindData);
	}
	
	/***
	 * Gets vault archive result representing archives of given store
	 * @param store The store to obtain archives of
	 * @return Archive result
	 * @throws Exception Mostl likely if there is an issue interacting with SQL.
	 */
	public VaultArchiveResult getArchives(VaultStore store) throws Exception{
		return getArchives(store,null);
	}
	
	/***
	 * Gets vault archive result based on provides list of stores and vault archive criteria
	 * @param stores The stores to query
	 * @param criteria The criteria used to obtain the archive result
	 * @return Vault archive result based on the provided stores list and criteria
	 * @throws Exception Most likely if there is an issue interacting with SQL.
	 */
	public VaultArchiveResult getArchives(List<VaultStore> stores, VaultArchiveCriteria criteria) throws Exception{
		logger.info("Server "+getDisplayName()+" fetching archives for stores:");
		for(VaultStore store : stores){
			logger.info("["+store.getName()+", "+store.getStoreEntryID()+"]");
		}
		
		if (criteria != null){
			logger.info("Archive Name Criteria: "+criteria.getArchiveNameCriteria());
		}
		List<Object> bindData = new ArrayList<Object>();
		StringBuilder whereClause = new StringBuilder();
		whereClause.append("WHERE VaultStoreEntryId IN (");
		whereClause.append(String.join(",",stores.stream().map(s -> { return "?";}).collect(Collectors.toList())));
		whereClause.append(")");
		for(VaultStore store : stores){
			bindData.add(store.getStoreEntryID());
		}
		if(criteria != null){
			String nameCriteria = criteria.getArchiveNameCriteria();
			if(nameCriteria != null && nameCriteria.trim().length() > 0){
				whereClause.append(" AND ArchiveName LIKE ?");
				bindData.add("%"+nameCriteria+"%");
			}
		}
		return new VaultArchiveResult(this,stores,whereClause.toString(),bindData);
	}

	public String getDisplayName() {
		return displayName;
	}
	
	public String getServerLocation(){
		return (String)databaseConnectionSettings.get("server");
	}

	@Override
	public String toString() {
		return getDisplayName();
	}
}
